import baekjoon.algorithm.dynamicProgramming.Step1;
import baekjoon.algorithm.graph.Step0;
import baekjoon.algorithm.recursion.Step2;
import baekjoon.datastructure.StackQueueDeque;
import baekjoon.math.Mathematics;

public class Main {
    public static void main(String[] args) throws Exception {
        // 별 찍기 - 11
//        new Step2().baekjoon2448();

        new Step0().baekjoon24445();

        // 풍선 터뜨리기
//        new StackQueueDeque().baekjoon2346();

        // 비트 연산자
//        int num1 = 5;
//        int num2 = 9;
//        System.out.println(num1 & num2);
//        System.out.println(num1 | num2);
//        System.out.println(num1 ^ num2);
    }
}

        // 정렬 알고리즘 풀이 다시 확인
        //  new Algorithm().baekjoon2751();
        //  new Algorithm().baekjoon11650();

        /* mergesort로 구현해서 시간 줄여보기 */
        //  new Algorithm().baekjoon18870();

        // 아래 다시 확인하기
        // new Algorithm1().baekjoon24267();

        // 아래 더 효율적으로 다시 풀기
        //  new Algorithm().baekjoon1436();

        // 약수, 배수, 소수 다시 풀기

        //  집합과 맵
        //  new SetAndMap().baekjoon11478();

        // 조합론 다시 풀기 (dp기초 nCr)

        // 시간개선 (arr[8001]로)
        // new AdvancedLevel2().baekjoon2108();

        // merge_sort 다시보기
        // new Recursion().baekjoon24060();

        // 시간 개선하기 (현재 0.28 -> 0.1초대로 개선하기)
        // new Recursion().baekjoon4779();

        // backtracking => 9663(N-Queen, 비스마스크), 14889(스타트와 링크) 다시 풀기
        
        // 스도쿠 다시 보기
